# Game

The Regal `Game` object is the API through which games are played. 

In a sense, any operation on a Regal game can be thought of as a pure function. A request (consisting of the player's command and the game state) is sent to the Game API, and a response (consisting of the game's output and the updated game state) is returned. The game's source and the original game state are never modified.

Regal was structured like this so that a client's only responsibilties are:

* Accepting user input
* Reporting game output
* Storing the game state (although awareness of the data's structure isn't needed)
* Calling the Regal API

The idea is that a Regal game is deterministic; i.e. it will always return the same output when given the same input. This makes debugging easier and means that no user-specific game data ever needs to be stored on the game serversâ€”in fact, a Regal game can be serverless! All one needs is a client that can store data and call the Regal API. Multiple clients playing multiple games can call the same API, and they won't interfere with each other.

## `GameResponse`

A `GameResponse` contains the output of a request's effect on the game and the new instance state of the game at that moment. A `GameResponse` is returned by the `Game` API whenever one of its methods is called.

The `GameResponse` schema is as follows:

```ts
interface GameResponse {
    instance: GameInstance;
    output: GameOutput;
}
```

### `GameOutput`

`GameOutput` is an interface that represents the output generated by a request. Its properties are as follows:

Property | Type | Required | Description
--- | --- | --- | ---
wasSuccessful | boolean | Yes | Will be false if an error occurred during the game's execution of the request.
error | RegalError | No | If `wasSuccessful` is false, this will contain the error that was thrown.
log | OutputLine[] | Yes | Contains any lines of text emitted by the game.

An `OutputLine` usually contains a line of text meant to notify the player of something that happened in the game. It has a `data` property of type `string`, and a `type` property that is of type `OutputLineType`.

The enum `OutputLineType` is used to convey semantic meaning of the `OutputLine` to the client. The types are:

OutputLineType | Description | Usage
--- | --- | ---
NORMAL | Standard output line; presented to the player normally. (Default) | Use for most game content.
MAJOR | Important line; emphasized to the player. | Use when something important happens, like a character dying, an achievement, win/loss of the game, etc.
MINOR | Non-important line; emphasized less than `NORMAL` lines, and won't always be shown to the player. | Use for repetitive/flavor text that might add a bit to the game experience but won't be missed if it isn't seen.
DEBUG | Meant for debugging purposes; only visible when the `DEBUG` option is enabled. | Debugging
SECTION_TITLE | Signifies the start of a new section or scene in the game. | In games that have scenes, rooms, or other disconnected sections. (i.e. "**West of House**")


## Calling the `Game` API

`Game` is a global object that contains the public API for interacting with a Regal game. 

It has six methods:

* `GetOptionCommand`
* `GetMetadataCommand`
* `PostPlayerCommand`
* `PostStartCommand`
* `PostUndoCommand`
* `PostOptionCommand`

Each of these methods returns a `GameResponse` object.

### `Game.GetOptionCommand(instance: GameInstance, options: string[])`

Outputs the values of the named game options.

#### Example

```ts
const response = Game.GetOptionCommand(myGame, [ "debug", "showMinor" ]);

response.output === {
    wasSuccessful: true,
    options: {
        debug: false,
        showMinor: true
    }
};
```

### `Game.GetMetadataCommand()`

Gets the game's metadata. Note that this is not specific to any game instance.

```ts
const response = Game.GetMetadataCommand();

response.output === {
    wasSuccessful: true,
    metadata: {
        title: "My Awesome Game",
        author: "Joe Cowman",
        version: "1.0.0",
        headline: "This is the best game ever.",
        description: "Let me tell you why this is the best game ever..."
    }
}
```

### `Game.PostPlayerCommand(instance: GameInstance, command: string)`

Posts a command that was spoken or typed by a player. Usually used to do something in the game.

```ts
const response = Game.PostPlayerCommand(myGame, "enter door");

response.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.NORMAL,
            data: "The door swings open with a creak."
        },
        {
            type: OutputLineType.SECTION_TITLE,
            data: "The Attic"
        }
    ]
};
```

### `Game.PostStartCommand(options: GameOption)`

Starts a new game with the option to override one or more `GameOption`s.

```ts
const response1 = Game.PostStartCommand();

reponse1.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.MAJOR,
            data: "WELCOME TO MY AWESOME GAME!"
        }
    ]
};

const response2 = Game.PostStartCommand({ debug: true });

response2.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.DEBUG,
            data: "Debugging enabled."
        },
        {
            type: OutputLineType.MAJOR,
            data: "WELCOME TO MY AWESOME GAME!"
        }
    ]
};
```

### `Game.PostUndoCommand(instance: GameInstance)`

Undoes the effects of the previous command.

```ts
const response1 = Game.PostUndoCommand(myGame);

response1.output === {
    wasSuccessful: true
};
```

If the previous command was not a `PlayerCommand`, an error will be thrown.

```ts
const response2 = Game.PostUndoCommand(response1.instance);

response2.output === {
    wasSuccessful: false,
    error: {
        message: "Can not undo an undo command; only a player command can be undone."
    }
};
```

### `Game.PostOptionCommand(instance: GameInstance, options: GameOption)`

Updates the values of the named game options.

```ts
const response = Game.PostOptionCommand(myGame, { debug: false });

response.output === {
    wasSuccessful: true
}

Game.GetOptionCommand(response.instance, [ "debug" ]).output.options.debug === false;
```