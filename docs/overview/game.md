# Game

The Regal `Game` object is the API through which games are played. 

In a sense, any operation on a Regal game can be thought of as a pure function. A request (consisting of the player's command and the game state) is sent to the Game API, and a response (consisting of the game's output and the updated game state) is returned. The game's source and the original game state are never modified.

Regal was structured like this so that a client's only responsibilties are:

* Accepting user input
* Reporting game output
* Storing the game state (although awareness of the data's structure isn't needed)
* Calling the Regal API

The idea is that a Regal game is deterministic; i.e. it will always return the same output when given the same input. This makes debugging easier and means that no user-specific game data ever needs to be stored on the game serversâ€”in fact, a Regal game can be serverless! All one needs is a client that can store data and call the Regal API. Multiple clients playing multiple games can call the same API, and they won't interfere with each other.

## Requests and Responses

Interaction with a Regal game is done through the `Game` API. The API expects a `GameRequest` and returns a `GameResponse`.

### `GameRequest`

A `GameRequest` contains the player's command and the instance state of the game at that moment. A `GameRequest` is sent to the `Game` API whenever a command (such as "open door") is created.

The `GameRequest` schema is as follows:

```ts
interface GameRequest {
    command: GameCommand;
    instance?: GameInstance;
}
```

#### `GameCommand`

`GameCommand` is an interface that represents a command. Its schema is as follows:

```ts
interface GameCommand {
    type: GameCommandType;
    data: any;
}
```

The type of `GameCommand.data` is determined by the value of `GameCommand.type`. Different classes of `GameCommand` exist for different types of commands. 

The most common class of `GameCommand` is `PlayerCommand`, which is used for all commands that are spoken or typed by a player. For example, if a player entered the command "go west," the following `PlayerCommand` would be generated:

```ts
{
    type: GameCommandType.PlayerCommand;
    data: "go west";
}
```

The following table shows the different classes of commands that are supported by Regal:

Class | Command Data Type | Description
--- | --- | ---
PlayerCommand | string | Command spoken or typed by a player; usually used to do something in the game.
StartCommand | object | Starts a new game. The object passed in as the command's data can contain optional arguments specific to the game.
UndoCommand | void | Undoes the effects of the previous command. If the previous command was not a PlayerCommand, an error will be thrown.
GetOptionCommand | string[] | Returns the values of the named game options.
SetOptionCommand | GameOption[] | Sets the values of the named game options.
TimerCommand | TBA | TBA

### `GameResponse`

A `GameResponse` contains the output of the request's effect on the game and the new instance state of the game at that moment. A `GameResponse` is returned by the `Game` API whenever a `GameRequest` is sent to it.

The `GameResponse` schema is as follows:

```ts
interface GameResponse {
    instance: GameInstance;
    output: GameOutput;
}
```

#### `GameOutput`

`GameOutput` is an interface that represents the output generated by a request. Its properties are as follows:

Property | Type | Required | Description
--- | --- | --- | ---
wasSuccessful | boolean | Yes | Will be false if an error occurred during the game's execution of the request.
error | RegalError | No | If `wasSuccessful` is false, this will contain the error that was thrown.
log | OutputLine[] | Yes | Contains any lines of text emitted by the game.

An `OutputLine` usually contains a line of text meant to notify the player of something that happened in the game. It has a `data` property of type `string`, and a `type` property that is of type `OutputLineType`.

The enum `OutputLineType` is used to convey semantic meaning of the `OutputLine` to the client. The types are:

OutputLineType | Description | Usage
--- | --- | ---
NORMAL | Standard output line; presented to the player normally. (Default) | Use for most game content.
MAJOR | Important line; emphasized to the player. | Use when something important happens, like a character dying, an achievement, win/loss of the game, etc.
MINOR | Non-important line; emphasized less than `NORMAL` lines, and won't always be shown to the player. | Use for repetitive/flavor text that might add a bit to the game experience but won't be missed if it isn't seen.
DEBUG | Meant for debugging purposes; only visible when the `DEBUG` option is enabled. | Debugging
SECTION_TITLE | Signifies the start of a new section or scene in the game. | In games that have scenes, rooms, or other disconnected sections. (i.e. "**West of House**")

## Calling the `Game` API

`Game` is a global object that contains the public API for interacting with a Regal game. It has the following methods:

### `Game.GetOptionCommand(instance: GameInstance, options: string[])`

Outputs the values of the named game options.

#### Example

```ts
const response = Game.GetOptionCommand(myGame, [ "debug", "showMinor" ]);

response.output === {
    wasSuccessful: true,
    options: {
        debug: false,
        showMinor: true
    }
};
```

### `Game.GetMetadataCommand()`

Gets the game's metadata. Note that this is not specific to any game instance.

```ts
const response = Game.GetMetadataCommand();

response.output === {
    wasSuccessful: true,
    metadata: {
        title: "My Awesome Game",
        author: "Joe Cowman",
        version: "1.0.0",
        headline: "This is the best game ever.",
        description: "Let me tell you why this is the best game ever..."
    }
}
```

### `Game.PostPlayerCommand(instance: GameInstance, command: string)`

Posts a command that was spoken or typed by a player. Usually used to do something in the game.

```ts
const response = Game.PostPlayerCommand(myGame, "enter door");

response.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.NORMAL,
            data: "The door swings open with a creak."
        },
        {
            type: OutputLineType.SECTION_TITLE,
            data: "The Attic"
        }
    ]
};
```

### `Game.PostStartCommand(options: GameOption)`

Starts a new game with the option to override one or more `GameOption`s.

```ts
const response1 = Game.PostStartCommand();

reponse1.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.MAJOR,
            data: "WELCOME TO MY AWESOME GAME!"
        }
    ]
};

const response2 = Game.PostStartCommand({ debug: true });

response2.output === {
    wasSuccessful: true,
    log: [
        {
            type: OutputLineType.DEBUG,
            data: "Debugging enabled."
        },
        {
            type: OutputLineType.MAJOR,
            data: "WELCOME TO MY AWESOME GAME!"
        }
    ]
};
```

### `Game.PostUndoCommand(instance: GameInstance)`

Undoes the effects of the previous command.

```ts
const response1 = Game.PostUndoCommand(myGame);

response1.output === {
    wasSuccessful: true
};
```

If the previous command was not a `PlayerCommand`, an error will be thrown.

```ts
const response2 = Game.PostUndoCommand(response1.instance);

response2.output === {
    wasSuccessful: false,
    error: {
        message: "Can not undo an undo command; only a player command."
    }
};
```

### `Game.PostOptionCommand(instance: GameInstance, options: GameOption)`

Updates the values of the named game options.

```ts
const response = Game.PostOptionCommand(myGame, { debug: false });

response.output === {
    wasSuccessful: true
}

Game.GetOptionCommand(response.instance, [ "debug" ]).output.options.debug === false;
```